<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
   

    @media (max-width: 600px) {
      nav ul {
        flex-direction: column;
      }

      .content div {
        width: 90%;
      }
    }
  </style>
</head>
<body>

  
 <h1>SECTION D</h1>
  <h1>Q1: Evaluate Postfix Expression Using Stack in C</h1>
  
  <div class="section">
    <p><strong>Postfix Expression:</strong> <code>2 3 1 * + 9 -</code> (Equivalent to <code>2 + (3 * 1) - 9</code>)</p>

    <h2>C Code:</h2>
    <pre><code>#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define MAX 100

int stack[MAX];
int top = -1;

void push(int val) {
    stack[++top] = val;
}

int pop() {
    return stack[top--];
}

int evaluatePostfix(char *exp) {
    char *token = strtok(exp, " ");
    while (token != NULL) {
        if (isdigit(token[0])) {
            push(atoi(token));
        } else {
            int val2 = pop();
            int val1 = pop();
            switch (token[0]) {
                case '+': push(val1 + val2); break;
                case '-': push(val1 - val2); break;
                case '*': push(val1 * val2); break;
                case '/': push(val1 / val2); break;
            }
        }
        token = strtok(NULL, " ");
    }
    return pop();
}

int main() {
    char expr[] = "2 3 1 * + 9 -";
    printf("Result = %d\n", evaluatePostfix(expr));
    return 0;
}</code></pre>

    <h2>Output:</h2>
    <pre><code>Result = -4</code></pre>
  </div>

  <h1>Q2: Construct AVL Tree from Data</h1>

  <div class="section">
    <p><strong>Given data:</strong> <code>21, 26, 30, 9, 4, 14, 28, 18, 15, 10</code></p>
    <p><strong>AVL Tree Rules:</strong> Balanced Binary Search Tree with Balance Factor ‚àà [-1, 0, 1]</p>

    <h2>Step-by-step Insertions with Rotations:</h2>
    <ul>
      <li>Insert 21 ‚Üí Root</li>
      <li>Insert 26 ‚Üí Right of 21</li>
      <li>Insert 30 ‚Üí Right of 26 ‚Üí <strong>RR Rotation at 21 ‚Üí Left Rotate</strong> ‚Üí New root: 26</li>
      <li>Insert 9 ‚Üí Left of 21</li>
      <li>Insert 4 ‚Üí Left of 9</li>
      <li>Insert 14 ‚Üí Right of 9</li>
      <li>Insert 28 ‚Üí Right of 30</li>
      <li>Insert 18 ‚Üí Right of 14</li>
      <li>Insert 15 ‚Üí Left of 18 ‚Üí <strong>RL Rotation at 14</strong> ‚Üí Right Rotate 18, then Left Rotate 14</li>
      <li>Insert 10 ‚Üí Left of 14 ‚Üí <strong>LR Rotation at 9</strong> ‚Üí Left Rotate 9, then Right Rotate 21</li>
    </ul>

    <h2>Final AVL Tree (Level Order):</h2>
    <pre><code>          26
        /    \
      14      30
     /  \     /
   10   21  28
  /    /  \
 4    15  18</code></pre>

    <p><strong>Visualization Tip:</strong> You can try the AVL Tree online visualizer here: <br>
      <a href="https://www.cs.usfca.edu/~galles/visualization/AVLtree.html" target="_blank">AVL Tree Visualizer</a>
    </p>
  </div>

<h1>SECTION C</h1>
    
  <h1>Q1: Library Book List - Remove Duplicate Book IDs</h1>

  <div class="section">
    <p><strong>Description:</strong> Maintain a list of Book IDs, ensure uniqueness by removing duplicates, and display the final list.</p>

    <h2>C Code:</h2>
    <pre><code>#include &lt;stdio.h&gt;

#define MAX 100

int removeDuplicates(int arr[], int n) {
    int temp[MAX];
    int i, j, k = 0;
    for (i = 0; i &lt; n; i++) {
        int duplicate = 0;
        for (j = 0; j &lt; k; j++) {
            if (arr[i] == temp[j]) {
                duplicate = 1;
                break;
            }
        }
        if (!duplicate) {
            temp[k++] = arr[i];
        }
    }

    for (i = 0; i &lt; k; i++) {
        arr[i] = temp[i];
    }
    return k; // new size
}

int main() {
    int books[MAX], n, i;

    printf("Enter number of books: ");
    scanf("%d", &amp;n);

    printf("Enter Book IDs:\n");
    for (i = 0; i &lt; n; i++) {
        scanf("%d", &amp;books[i]);
    }

    n = removeDuplicates(books, n);

    printf("\nUnique Book IDs in Library:\n");
    for (i = 0; i &lt; n; i++) {
        printf("%d ", books[i]);
    }
    printf("\n");

    return 0;
}</code></pre>

    <h2>Sample Output:</h2>
    <pre>
Enter number of books: 7
Enter Book IDs:
101 102 103 101 104 102 105

Unique Book IDs in Library:
101 102 103 104 105
    </pre>
  </div>

  <h1>Q2: Restaurant Order Queue using Circular Queue</h1>

  <div class="section">
    <p><strong>Description:</strong> A circular queue to manage orders in a restaurant where new orders wait if the queue is full.</p>

    <h2>C Code:</h2>
    <pre><code>#include &lt;stdio.h&gt;
#define SIZE 5

int queue[SIZE];
int front = -1, rear = -1;

int isFull() {
    return ((rear + 1) % SIZE == front);
}

int isEmpty() {
    return (front == -1);
}

void enqueue(int order) {
    if (isFull()) {
        printf("Queue is full. Order %d is waiting...\n", order);
        return;
    }
    if (isEmpty()) {
        front = rear = 0;
    } else {
        rear = (rear + 1) % SIZE;
    }
    queue[rear] = order;
    printf("Order %d added.\n", order);
}

void dequeue() {
    if (isEmpty()) {
        printf("Queue is empty. No orders to handle.\n");
        return;
    }
    printf("Order %d handled.\n", queue[front]);
    if (front == rear) {
        front = rear = -1; // Queue is now empty
    } else {
        front = (front + 1) % SIZE;
    }
}

void display() {
    if (isEmpty()) {
        printf("Queue is empty.\n");
        return;
    }

    printf("Current Orders in Queue: ");
    int i = front;
    while (1) {
        printf("%d ", queue[i]);
        if (i == rear)
            break;
        i = (i + 1) % SIZE;
    }
    printf("\n");
}

int main() {
    enqueue(101);
    enqueue(102);
    enqueue(103);
    enqueue(104);
    enqueue(105);
    enqueue(106); // Should wait

    display();

    dequeue();
    dequeue();

    enqueue(106); // Now it can be added
    enqueue(107); // Should wait again

    display();

    return 0;
}</code></pre>

    <h2>Sample Output:</h2>
    <pre>
Order 101 added.
Order 102 added.
Order 103 added.
Order 104 added.
Order 105 added.
Queue is full. Order 106 is waiting...

Current Orders in Queue: 101 102 103 104 105
Order 101 handled.
Order 102 handled.
Order 106 added.
Queue is full. Order 107 is waiting...

Current Orders in Queue: 103 104 105 106
    </pre>
  </div>

<h1>SECTION A AUR B KI ACCHI PHOTOS MIL SAKTI HAI KYA. VALUES UNCLEAR HAI</h1>
 <h1>ECTION B</h1>


  <h1>Q1: Hash Table with Chaining (Open Hashing)</h1>

  <div class="section">
    <p><strong>Given:</strong> Array size = 5, Hash function: <code>k mod 2</code></p>
    <p><strong>Keys:</strong> 22, 37, 56, 72, 91, 12, 77</p>

    <h2>Hash Function Calculation:</h2>
    <pre>
22 mod 2 = 0  
37 mod 2 = 1  
56 mod 2 = 0  
72 mod 2 = 0  
91 mod 2 = 1  
12 mod 2 = 0  
77 mod 2 = 1  
    </pre>

    <h2>Final Hash Table (using chaining):</h2>
    <table>
      <thead>
        <tr><th>Index</th><th>Chain</th></tr>
      </thead>
      <tbody>
        <tr><td>0</td><td>22 ‚Üí 56 ‚Üí 72 ‚Üí 12</td></tr>
        <tr><td>1</td><td>37 ‚Üí 91 ‚Üí 77</td></tr>
        <tr><td>2</td><td>‚Äî</td></tr>
        <tr><td>3</td><td>‚Äî</td></tr>
        <tr><td>4</td><td>‚Äî</td></tr>
      </tbody>
    </table>
  </div>

  <h1>Q2: Algorithm to Delete an Element from Max-Heap</h1>

  <div class="section">
    <h2>Max-Heap Deletion Algorithm:</h2>
    <pre>
Algorithm DeleteMax(heap[], n):
1. Replace root with last element ‚Üí heap[0] = heap[n - 1]
2. Reduce heap size by 1 ‚Üí n = n - 1
3. Set i = 0
4. while i has at least one child:
     a. Let maxChild be index of max(heap[2i + 1], heap[2i + 2])
     b. if heap[i] < heap[maxChild]:
           swap(heap[i], heap[maxChild])
           i = maxChild
        else:
           break
5. End
    </pre>
    <p><strong>Time Complexity:</strong> O(log n)</p>
  </div>

  <h1>Q3: C Program - Max Root-to-Leaf Path Sum in BST</h1>

  <div class="section">
    <h2>Given BST:</h2>
    <pre>
         10
        /  \
       5    15
      / \     \
     5   7     20

Max path = 20 ‚Üí 15 ‚Üí 10 = 45
    </pre>

    <h2>C Program:</h2>
    <pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct Node {
    int data;
    struct Node *left, *right;
} Node;

Node* newNode(int data) {
    Node* node = (Node*)malloc(sizeof(Node));
    node-&gt;data = data;
    node-&gt;left = node-&gt;right = NULL;
    return node;
}

int max(int a, int b) {
    return a &gt; b ? a : b;
}

int maxRootToLeafSum(Node* root) {
    if (root == NULL)
        return 0;
    int leftSum = maxRootToLeafSum(root-&gt;left);
    int rightSum = maxRootToLeafSum(root-&gt;right);
    return root-&gt;data + max(leftSum, rightSum);
}

int main() {
    Node* root = newNode(10);
    root-&gt;left = newNode(5);
    root-&gt;right = newNode(15);
    root-&gt;left-&gt;left = newNode(5);
    root-&gt;left-&gt;right = newNode(7);
    root-&gt;right-&gt;right = newNode(20);

    printf("Max Root-to-Leaf Path Sum: %d\n", maxRootToLeafSum(root));
    return 0;
}</code></pre>

    <h2>Output:</h2>
    <pre>Max Root-to-Leaf Path Sum: 45</pre>
  </div>


  <h1>Q4-Prim's Algorithm - Minimum Spanning Tree (MST)</h1>

  <div class="section">
    <h2>üîç Problem Statement:</h2>
    <p>Construct a Minimum Spanning Tree (MST) using <strong>Prim‚Äôs Algorithm</strong>, starting from node <strong>A</strong>. Show the selected edges and compute the total weight of the MST.</p>
  </div>

  <div class="section">
    <h2>üìä Given Graph (Edges with Weights):</h2>
    <table>
      <thead>
        <tr>
          <th>Edge</th>
          <th>Weight</th>
        </tr>
      </thead>
      <tbody>
        <tr><td>A ‚Äì D</td><td>7</td></tr>
        <tr><td>A ‚Äì B</td><td>10</td></tr>
        <tr><td>A ‚Äì C</td><td>17</td></tr>
        <tr><td>B ‚Äì C</td><td>16</td></tr>
        <tr><td>B ‚Äì E</td><td>20</td></tr>
        <tr><td>C ‚Äì E</td><td>6</td></tr>
        <tr><td>C ‚Äì F</td><td>2</td></tr>
        <tr><td>C ‚Äì G</td><td>1</td></tr>
        <tr><td>D ‚Äì F</td><td>26</td></tr>
        <tr><td>F ‚Äì G</td><td>5</td></tr>
      </tbody>
    </table>
  </div>

  <div class="section">
    <h2>‚öô Prim's Algorithm Steps (Starting from A):</h2>
    <pre>
1. Start at A
   ‚Üí Add edges: A‚ÄìD(7), A‚ÄìB(10), A‚ÄìC(17)

2. Choose A‚ÄìD (7) ‚Üí MST = {A, D}
   ‚Üí Add D‚ÄìF(26)

3. Choose A‚ÄìB (10) ‚Üí MST = {A, D, B}
   ‚Üí Add B‚ÄìC(16), B‚ÄìE(20)

4. Choose B‚ÄìC (16) ‚Üí MST = {A, D, B, C}
   ‚Üí Add C‚ÄìE(6), C‚ÄìF(2), C‚ÄìG(1)

5. Choose C‚ÄìG (1) ‚Üí MST = {A, D, B, C, G}
   ‚Üí Add F‚ÄìG(5)

6. Choose C‚ÄìF (2) ‚Üí MST = {A, D, B, C, G, F}

7. Choose C‚ÄìE (6) ‚Üí MST = {A, D, B, C, G, F, E}

‚úÖ All nodes covered
    </pre>
  </div>

  <div class="section">
    <h2>üå≤ Final MST Edges:</h2>
    <table>
      <thead>
        <tr>
          <th>Edge</th>
          <th>Weight</th>
        </tr>
      </thead>
      <tbody>
        <tr><td>A ‚Äì D</td><td>7</td></tr>
        <tr><td>A ‚Äì B</td><td>10</td></tr>
        <tr><td>B ‚Äì C</td><td>16</td></tr>
        <tr><td>C ‚Äì G</td><td>1</td></tr>
        <tr><td>C ‚Äì F</td><td>2</td></tr>
        <tr><td>C ‚Äì E</td><td>6</td></tr>
      </tbody>
    </table>
  </div>

  <div class="section">
    <h2>üßÆ Total Weight of MST:</h2>
    <pre>7 + 10 + 16 + 1 + 2 + 6 = <strong>42</strong></pre>
  </div>


  <h1>SECTION A</h1>
  <h1>Q5-Difference between BST and AVL Tree</h1>

  <table>
    <tr>
      <th>Feature</th>
      <th>Binary Search Tree (BST)</th>
      <th>AVL Tree</th>
    </tr>
    <tr>
      <td>Definition</td>
      <td>A binary tree where left &lt; root &lt; right</td>
      <td>A self-balancing BST with balance factor -1, 0, or +1</td>
    </tr>
    <tr>
      <td>Balance Condition</td>
      <td>No strict balancing</td>
      <td>Strictly balanced using rotations</td>
    </tr>
    <tr>
      <td>Time Complexity (Search)</td>
      <td>Average: O(log n), Worst: O(n)</td>
      <td>Always O(log n)</td>
    </tr>
    <tr>
      <td>Rotations</td>
      <td>Not used</td>
      <td>Used to maintain balance</td>
    </tr>
    <tr>
      <td>Height Difference</td>
      <td>Can be unbalanced</td>
      <td>Height difference ‚â§ 1 for each node</td>
    </tr>
    <tr>
      <td>Efficiency</td>
      <td>Can degrade with skewed data</td>
      <td>Guaranteed efficiency</td>
    </tr>
    <tr>
      <td>Use Case</td>
      <td>Data is random, balance not critical</td>
      <td>Search and balance are both critical</td>
    </tr>
    <tr>
      <td>Extra Space</td>
      <td>Less (no balance info stored)</td>
      <td>More (balance factor stored per node)</td>
    </tr>
  </table>


  
  </body>
</html>
