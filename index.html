<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
   

    @media (max-width: 600px) {
      nav ul {
        flex-direction: column;
      }

      .content div {
        width: 90%;
      }
    }
  </style>
</head>
<body>

  
 <h1>SECTION D</h1>
  <h1>Q1: Evaluate Postfix Expression Using Stack in C</h1>
  
  <div class="section">
    <p><strong>Postfix Expression:</strong> <code>2 3 1 * + 9 -</code> (Equivalent to <code>2 + (3 * 1) - 9</code>)</p>

    <h2>C Code:</h2>
    <pre><code>#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define MAX 100

int stack[MAX];
int top = -1;

void push(int val) {
    stack[++top] = val;
}

int pop() {
    return stack[top--];
}

int evaluatePostfix(char *exp) {
    char *token = strtok(exp, " ");
    while (token != NULL) {
        if (isdigit(token[0])) {
            push(atoi(token));
        } else {
            int val2 = pop();
            int val1 = pop();
            switch (token[0]) {
                case '+': push(val1 + val2); break;
                case '-': push(val1 - val2); break;
                case '*': push(val1 * val2); break;
                case '/': push(val1 / val2); break;
            }
        }
        token = strtok(NULL, " ");
    }
    return pop();
}

int main() {
    char expr[] = "2 3 1 * + 9 -";
    printf("Result = %d\n", evaluatePostfix(expr));
    return 0;
}</code></pre>

    <h2>Output:</h2>
    <pre><code>Result = -4</code></pre>
  </div>

  <h1>Q2: Construct AVL Tree from Data</h1>

  <div class="section">
    <p><strong>Given data:</strong> <code>21, 26, 30, 9, 4, 14, 28, 18, 15, 10</code></p>
    <p><strong>AVL Tree Rules:</strong> Balanced Binary Search Tree with Balance Factor ∈ [-1, 0, 1]</p>

    <h2>Step-by-step Insertions with Rotations:</h2>
    <ul>
      <li>Insert 21 → Root</li>
      <li>Insert 26 → Right of 21</li>
      <li>Insert 30 → Right of 26 → <strong>RR Rotation at 21 → Left Rotate</strong> → New root: 26</li>
      <li>Insert 9 → Left of 21</li>
      <li>Insert 4 → Left of 9</li>
      <li>Insert 14 → Right of 9</li>
      <li>Insert 28 → Right of 30</li>
      <li>Insert 18 → Right of 14</li>
      <li>Insert 15 → Left of 18 → <strong>RL Rotation at 14</strong> → Right Rotate 18, then Left Rotate 14</li>
      <li>Insert 10 → Left of 14 → <strong>LR Rotation at 9</strong> → Left Rotate 9, then Right Rotate 21</li>
    </ul>

    <h2>Final AVL Tree (Level Order):</h2>
    <pre><code>          26
        /    \
      14      30
     /  \     /
   10   21  28
  /    /  \
 4    15  18</code></pre>

    <p><strong>Visualization Tip:</strong> You can try the AVL Tree online visualizer here: <br>
      <a href="https://www.cs.usfca.edu/~galles/visualization/AVLtree.html" target="_blank">AVL Tree Visualizer</a>
    </p>
  </div>

<h1>SECTION C</h1>
    
  <h1>Q1: Library Book List - Remove Duplicate Book IDs</h1>

  <div class="section">
    <p><strong>Description:</strong> Maintain a list of Book IDs, ensure uniqueness by removing duplicates, and display the final list.</p>

    <h2>C Code:</h2>
    <pre><code>#include &lt;stdio.h&gt;

#define MAX 100

int removeDuplicates(int arr[], int n) {
    int temp[MAX];
    int i, j, k = 0;
    for (i = 0; i &lt; n; i++) {
        int duplicate = 0;
        for (j = 0; j &lt; k; j++) {
            if (arr[i] == temp[j]) {
                duplicate = 1;
                break;
            }
        }
        if (!duplicate) {
            temp[k++] = arr[i];
        }
    }

    for (i = 0; i &lt; k; i++) {
        arr[i] = temp[i];
    }
    return k; // new size
}

int main() {
    int books[MAX], n, i;

    printf("Enter number of books: ");
    scanf("%d", &amp;n);

    printf("Enter Book IDs:\n");
    for (i = 0; i &lt; n; i++) {
        scanf("%d", &amp;books[i]);
    }

    n = removeDuplicates(books, n);

    printf("\nUnique Book IDs in Library:\n");
    for (i = 0; i &lt; n; i++) {
        printf("%d ", books[i]);
    }
    printf("\n");

    return 0;
}</code></pre>

    <h2>Sample Output:</h2>
    <pre>
Enter number of books: 7
Enter Book IDs:
101 102 103 101 104 102 105

Unique Book IDs in Library:
101 102 103 104 105
    </pre>
  </div>

  <h1>Q2: Restaurant Order Queue using Circular Queue</h1>

  <div class="section">
    <p><strong>Description:</strong> A circular queue to manage orders in a restaurant where new orders wait if the queue is full.</p>

    <h2>C Code:</h2>
    <pre><code>#include &lt;stdio.h&gt;
#define SIZE 5

int queue[SIZE];
int front = -1, rear = -1;

int isFull() {
    return ((rear + 1) % SIZE == front);
}

int isEmpty() {
    return (front == -1);
}

void enqueue(int order) {
    if (isFull()) {
        printf("Queue is full. Order %d is waiting...\n", order);
        return;
    }
    if (isEmpty()) {
        front = rear = 0;
    } else {
        rear = (rear + 1) % SIZE;
    }
    queue[rear] = order;
    printf("Order %d added.\n", order);
}

void dequeue() {
    if (isEmpty()) {
        printf("Queue is empty. No orders to handle.\n");
        return;
    }
    printf("Order %d handled.\n", queue[front]);
    if (front == rear) {
        front = rear = -1; // Queue is now empty
    } else {
        front = (front + 1) % SIZE;
    }
}

void display() {
    if (isEmpty()) {
        printf("Queue is empty.\n");
        return;
    }

    printf("Current Orders in Queue: ");
    int i = front;
    while (1) {
        printf("%d ", queue[i]);
        if (i == rear)
            break;
        i = (i + 1) % SIZE;
    }
    printf("\n");
}

int main() {
    enqueue(101);
    enqueue(102);
    enqueue(103);
    enqueue(104);
    enqueue(105);
    enqueue(106); // Should wait

    display();

    dequeue();
    dequeue();

    enqueue(106); // Now it can be added
    enqueue(107); // Should wait again

    display();

    return 0;
}</code></pre>

    <h2>Sample Output:</h2>
    <pre>
Order 101 added.
Order 102 added.
Order 103 added.
Order 104 added.
Order 105 added.
Queue is full. Order 106 is waiting...

Current Orders in Queue: 101 102 103 104 105
Order 101 handled.
Order 102 handled.
Order 106 added.
Queue is full. Order 107 is waiting...

Current Orders in Queue: 103 104 105 106
    </pre>
  </div>



  
  </body>
</html>
